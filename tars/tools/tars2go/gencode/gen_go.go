package gencode

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"path/filepath"
	"runtime"
	"strconv"
	"strings"
	"sync"

	"github.com/TarsCloud/TarsGo/tars/tools/tars2go/ast"
	"github.com/TarsCloud/TarsGo/tars/tools/tars2go/options"
	"github.com/TarsCloud/TarsGo/tars/tools/tars2go/parse"
	"github.com/TarsCloud/TarsGo/tars/tools/tars2go/token"
	"github.com/TarsCloud/TarsGo/tars/tools/tars2go/utils"
	"github.com/TarsCloud/TarsGo/tars/tools/tars2go/version"
)

var (
	fileMap sync.Map
)

// GenGo record go code information.
type GenGo struct {
	opt      *options.Options
	code     bytes.Buffer
	vc       int // var count. Used to generate unique variable names
	filepath string
	prefix   string
	module   *ast.ModuleInfo

	// proto file name(not include .tars)
	ProtoName string
}

// NewGenGo build up a new filepath
func NewGenGo(opt *options.Options, filepath string) *GenGo {
	if opt.Outdir != "" && !strings.HasSuffix(opt.Outdir, "/") {
		opt.Outdir += "/"
	}

	return &GenGo{opt: opt, filepath: filepath, prefix: opt.Outdir, ProtoName: utils.Path2ProtoName(filepath)}
}

func getShortTypeName(src string) string {
	vec := strings.Split(src, "::")
	return vec[len(vec)-1]
}

func errString(hasRet bool) string {
	var retStr string
	if hasRet {
		retStr = "return ret, err"
	} else {
		retStr = "return err"
	}
	return `if err != nil {
  ` + retStr + `
  }
`
}

func genForHead(vc string) string {
	i := `i` + vc
	e := `e` + vc
	return ` for ` + i + `,` + e + ` := int32(0), length;` + i + `<` + e + `;` + i + `++ `
}

// Gen to parse file.
func (gen *GenGo) Gen() {
	defer func() {
		if err := recover(); err != nil {
			fmt.Println(err)
			// set exit code
			os.Exit(1)
		}
	}()

	gen.module = parse.NewParse(gen.opt, gen.filepath, make([]string, 0))
	gen.genAll()
}

func (gen *GenGo) genAll() {
	if _, ok := fileMap.Load(gen.filepath); ok {
		// already compiled
		return
	}
	fileMap.Store(gen.filepath, struct{}{})

	gen.module.Rename(gen.opt.ModuleUpper)
	gen.genInclude(gen.module.IncModule)

	gen.code.Reset()
	gen.genHead()
	gen.genPackage()

	for _, v := range gen.module.Enum {
		gen.genEnum(&v)
	}

	gen.genConst(gen.module.Const)

	for _, v := range gen.module.Struct {
		gen.genStruct(&v)
	}
	if len(gen.module.Enum) > 0 || len(gen.module.Const) > 0 || len(gen.module.Struct) > 0 {
		gen.saveToSourceFile(utils.Path2ProtoName(gen.filepath) + ".go")
	}

	for _, v := range gen.module.Interface {
		gen.genInterface(&v)
	}
}

func (gen *GenGo) genErr(err string) {
	panic(err)
}

func (gen *GenGo) saveToSourceFile(filename string) {
	var beauty []byte
	var err error
	prefix := gen.prefix

	if !gen.opt.E {
		beauty, err = format.Source(gen.code.Bytes())
		if err != nil {
			if gen.opt.Debug {
				fmt.Println("------------------")
				fmt.Println(string(gen.code.Bytes()))
				fmt.Println("------------------")
			}
			gen.genErr("go fmt fail. " + filename + " " + err.Error())
		}
	} else {
		beauty = gen.code.Bytes()
	}

	if filename == "stdout" {
		fmt.Println(string(beauty))
	} else {
		var mkPath string
		if gen.opt.ModuleCycle {
			mkPath = prefix + gen.ProtoName + "/" + gen.module.Name
		} else {
			mkPath = prefix + gen.module.Name
		}
		err = os.MkdirAll(mkPath, 0766)

		if err != nil {
			gen.genErr(err.Error())
		}
		err = ioutil.WriteFile(mkPath+"/"+filename, beauty, 0666)

		if err != nil {
			gen.genErr(err.Error())
		}
	}
}

func (gen *GenGo) genVariableName(prefix, name string) string {
	if strings.HasPrefix(name, "(*") && strings.HasSuffix(name, ")") {
		return strings.Trim(name, "()")
	}
	return prefix + name
}

func (gen *GenGo) genHead() {
	gen.code.WriteString(`// Package ` + gen.module.Name + ` comment
// This file was generated by tars2go ` + version.VERSION + `
// Generated from ` + filepath.Base(gen.filepath) + `
`)
}

func (gen *GenGo) genPackage() {
	gen.code.WriteString("package " + gen.module.Name + "\n\n")
	gen.code.WriteString(`
import (
	"fmt"

`)
	gen.code.WriteString(`"` + gen.opt.TarsPath + "/protocol/codec\"\n")

	mImports := make(map[string]bool)
	for _, st := range gen.module.Struct {
		if gen.opt.ModuleCycle {
			for k, v := range st.DependModuleWithJce {
				gen.genStructImport(k, v, mImports)
			}
		} else {
			for k := range st.DependModule {
				gen.genStructImport(k, "", mImports)
			}
		}
	}
	for path := range mImports {
		gen.code.WriteString(path + "\n")
	}

	gen.code.WriteString(`)

	// Reference imports to suppress errors if they are not otherwise used.
	var _ = fmt.Errorf
	var _ = codec.FromInt8

`)
}

func (gen *GenGo) genStructImport(module string, protoName string, mImports map[string]bool) {
	var moduleStr string
	var jcePath string
	var moduleAlia string
	if gen.opt.ModuleCycle {
		moduleStr = module[len(protoName)+1:]
		jcePath = protoName + "/"
		moduleAlia = module + " "
	} else {
		moduleStr = module
	}

	for _, p := range gen.opt.Imports {
		if strings.HasSuffix(p, "/"+moduleStr) {
			mImports[`"`+p+`"`] = true
			return
		}
	}

	if gen.opt.ModuleUpper {
		moduleAlia = utils.UpperFirstLetter(moduleAlia)
	}

	// example:
	// TarsTest.tars, MyApp
	// gomod:
	// github.com/xxx/yyy/tars-protocol/MyApp
	// github.com/xxx/yyy/tars-protocol/TarsTest/MyApp
	//
	// gopath:
	// MyApp
	// TarsTest/MyApp
	var modulePath string
	if gen.opt.Module != "" {
		mf := filepath.Clean(filepath.Join(gen.opt.Module, gen.prefix))
		if runtime.GOOS == "windows" {
			mf = strings.ReplaceAll(mf, string(os.PathSeparator), string('/'))
		}
		modulePath = fmt.Sprintf("%s/%s%s", mf, jcePath, moduleStr)
	} else {
		modulePath = fmt.Sprintf("%s%s", jcePath, moduleStr)
	}
	mImports[moduleAlia+`"`+modulePath+`"`] = true
}

func (gen *GenGo) genIFPackage(itf *ast.InterfaceInfo) {
	gen.code.WriteString("package " + gen.module.Name + "\n\n")
	gen.code.WriteString(`
import (
	"bytes"
	"context"
	"fmt"
	"unsafe"
	"encoding/json"
`)
	tarsPath := gen.opt.TarsPath
	if gen.opt.AddServant {
		gen.code.WriteString(`"` + tarsPath + "\"\n")
	}

	gen.code.WriteString(`"` + tarsPath + "/protocol/res/requestf\"\n")
	gen.code.WriteString(`m "` + tarsPath + "/model\"\n")
	gen.code.WriteString(`"` + tarsPath + "/protocol/codec\"\n")
	gen.code.WriteString(`"` + tarsPath + "/protocol/tup\"\n")
	gen.code.WriteString(`"` + tarsPath + "/protocol/res/basef\"\n")
	gen.code.WriteString(`"` + tarsPath + "/util/tools\"\n")
	gen.code.WriteString(`"` + tarsPath + "/util/endpoint\"\n")
	gen.code.WriteString(`"` + tarsPath + "/util/current\"\n")
	if !gen.opt.WithoutTrace {
		gen.code.WriteString("tarstrace \"" + tarsPath + "/util/trace\"\n")
	}

	if gen.opt.ModuleCycle == true {
		for k, v := range itf.DependModuleWithJce {
			gen.genIFImport(k, v)
		}
	} else {
		for k := range itf.DependModule {
			gen.genIFImport(k, "")
		}
	}
	gen.code.WriteString(`)

	// Reference imports to suppress errors if they are not otherwise used.
	var (
		_ = fmt.Errorf
		_ = codec.FromInt8
		_ = unsafe.Pointer(nil)
		_ = bytes.ErrTooLarge
	)
`)
}

func (gen *GenGo) genIFImport(module string, protoName string) {
	var moduleStr string
	var jcePath string
	var moduleAlia string
	if gen.opt.ModuleCycle {
		moduleStr = module[len(protoName)+1:]
		jcePath = protoName + "/"
		moduleAlia = module + " "
	} else {
		moduleStr = module
	}
	for _, p := range gen.opt.Imports {
		if strings.HasSuffix(p, "/"+moduleStr) {
			gen.code.WriteString(`"` + p + `"` + "\n")
			return
		}
	}

	if gen.opt.ModuleUpper {
		moduleAlia = utils.UpperFirstLetter(moduleAlia)
	}

	// example:
	// TarsTest.tars, MyApp
	// gomod:
	// github.com/xxx/yyy/tars-protocol/MyApp
	// github.com/xxx/yyy/tars-protocol/TarsTest/MyApp
	//
	// gopath:
	// MyApp
	// TarsTest/MyApp
	var modulePath string
	if gen.opt.Module != "" {
		mf := filepath.Clean(filepath.Join(gen.opt.Module, gen.prefix))
		if runtime.GOOS == "windows" {
			mf = strings.ReplaceAll(mf, string(os.PathSeparator), string('/'))
		}
		modulePath = fmt.Sprintf("%s/%s%s", mf, jcePath, moduleStr)
	} else {
		modulePath = fmt.Sprintf("%s%s", jcePath, moduleStr)
	}
	gen.code.WriteString(moduleAlia + `"` + modulePath + `"` + "\n")
}

func (gen *GenGo) genType(ty *ast.VarType) string {
	ret := ""
	switch ty.Type {
	case token.TBool:
		ret = "bool"
	case token.TInt:
		if ty.Unsigned {
			ret = "uint32"
		} else {
			ret = "int32"
		}
	case token.TShort:
		if ty.Unsigned {
			ret = "uint16"
		} else {
			ret = "int16"
		}
	case token.TByte:
		if ty.Unsigned {
			ret = "uint8"
		} else {
			ret = "int8"
		}
	case token.TLong:
		if ty.Unsigned {
			ret = "uint64"
		} else {
			ret = "int64"
		}
	case token.TFloat:
		ret = "float32"
	case token.TDouble:
		ret = "float64"
	case token.TString:
		ret = "string"
	case token.TVector:
		ret = "[]" + gen.genType(ty.TypeK)
	case token.TMap:
		ret = "map[" + gen.genType(ty.TypeK) + "]" + gen.genType(ty.TypeV)
	case token.Name:
		ret = strings.Replace(ty.TypeSt, "::", ".", -1)
		vec := strings.Split(ty.TypeSt, "::")
		for i := range vec {
			if gen.opt.ModuleUpper {
				vec[i] = utils.UpperFirstLetter(vec[i])
			} else {
				if i == (len(vec) - 1) {
					vec[i] = utils.UpperFirstLetter(vec[i])
				}
			}
		}
		ret = strings.Join(vec, ".")
	case token.TArray:
		ret = "[" + fmt.Sprintf("%v", ty.TypeL) + "]" + gen.genType(ty.TypeK)
	default:
		gen.genErr("Unknown Type " + token.Value(ty.Type))
	}
	return ret
}

func (gen *GenGo) genStructDefine(st *ast.StructInfo) {
	c := &gen.code
	c.WriteString("// " + st.Name + " struct implement\n")
	c.WriteString("type " + st.Name + " struct {\n")

	for _, v := range st.Mb {
		if gen.opt.JsonOmitEmpty {
			c.WriteString("\t" + v.Key + " " + gen.genType(v.Type) + " `json:\"" + v.OriginKey + ",omitempty\"`\n")
		} else {
			c.WriteString("\t" + v.Key + " " + gen.genType(v.Type) + " `json:\"" + v.OriginKey + "\"`\n")
		}
	}
	c.WriteString("}\n")
}

func (gen *GenGo) genFunResetDefault(st *ast.StructInfo) {
	c := &gen.code

	c.WriteString("func (st *" + st.Name + ") ResetDefault() {\n")

	for _, v := range st.Mb {
		if v.Type.CType == token.Struct {
			c.WriteString("st." + v.Key + ".ResetDefault()\n")
		}
		if v.Default == "" {
			continue
		}
		c.WriteString("st." + v.Key + " = " + v.Default + "\n")
	}
	c.WriteString("}\n")
}

func (gen *GenGo) genWriteSimpleList(mb *ast.StructMember, prefix string, hasRet bool) {
	c := &gen.code
	tag := strconv.Itoa(int(mb.Tag))
	unsign := "Int8"
	if mb.Type.TypeK.Unsigned {
		unsign = "Uint8"
	}
	errStr := errString(hasRet)
	c.WriteString(`
err = buf.WriteHead(codec.SimpleList, ` + tag + `)
` + errStr + `
err = buf.WriteHead(codec.BYTE, 0)
` + errStr + `
err = buf.WriteInt32(int32(len(` + gen.genVariableName(prefix, mb.Key) + `)), 0)
` + errStr + `
err = buf.WriteSlice` + unsign + `(` + gen.genVariableName(prefix, mb.Key) + `)
` + errStr + `
`)
}

func (gen *GenGo) genWriteVector(mb *ast.StructMember, prefix string, hasRet bool) {
	c := &gen.code

	// SimpleList
	if mb.Type.TypeK.Type == token.TByte && !mb.Type.TypeK.Unsigned {
		gen.genWriteSimpleList(mb, prefix, hasRet)
		return
	}
	errStr := errString(hasRet)

	// LIST
	tag := strconv.Itoa(int(mb.Tag))
	c.WriteString(`
err = buf.WriteHead(codec.LIST, ` + tag + `)
` + errStr + `
err = buf.WriteInt32(int32(len(` + gen.genVariableName(prefix, mb.Key) + `)), 0)
` + errStr + `
for _, v := range ` + gen.genVariableName(prefix, mb.Key) + ` {
`)
	// for _, v := range can nesting for _, v := range，does not conflict, support multidimensional arrays

	dummy := &ast.StructMember{}
	dummy.Type = mb.Type.TypeK
	dummy.Key = "v"
	gen.genWriteVar(dummy, "", hasRet)

	c.WriteString("}\n")
}

func (gen *GenGo) genWriteArray(mb *ast.StructMember, prefix string, hasRet bool) {
	c := &gen.code

	// SimpleList
	if mb.Type.TypeK.Type == token.TByte && !mb.Type.TypeK.Unsigned {
		gen.genWriteSimpleList(mb, prefix, hasRet)
		return
	}
	errStr := errString(hasRet)

	// LIST
	tag := strconv.Itoa(int(mb.Tag))
	c.WriteString(`
err = buf.WriteHead(codec.LIST, ` + tag + `)
` + errStr + `
err = buf.WriteInt32(int32(len(` + gen.genVariableName(prefix, mb.Key) + `)), 0)
` + errStr + `
for _, v := range ` + gen.genVariableName(prefix, mb.Key) + ` {
`)
	// for _, v := range can nesting for _, v := range，does not conflict, support multidimensional arrays

	dummy := &ast.StructMember{}
	dummy.Type = mb.Type.TypeK
	dummy.Key = "v"
	gen.genWriteVar(dummy, "", hasRet)

	c.WriteString("}\n")
}

func (gen *GenGo) genWriteStruct(mb *ast.StructMember, prefix string, hasRet bool) {
	c := &gen.code
	tag := strconv.Itoa(int(mb.Tag))
	c.WriteString(`
err = ` + prefix + mb.Key + `.WriteBlock(buf, ` + tag + `)
` + errString(hasRet) + `
`)
}

func (gen *GenGo) genWriteMap(mb *ast.StructMember, prefix string, hasRet bool) {
	c := &gen.code
	tag := strconv.Itoa(int(mb.Tag))
	vc := strconv.Itoa(gen.vc)
	gen.vc++
	errStr := errString(hasRet)
	c.WriteString(`
err = buf.WriteHead(codec.MAP, ` + tag + `)
` + errStr + `
err = buf.WriteInt32(int32(len(` + gen.genVariableName(prefix, mb.Key) + `)), 0)
` + errStr + `
for k` + vc + `, v` + vc + ` := range ` + gen.genVariableName(prefix, mb.Key) + ` {
`)
	// for _, v := range can nesting for _, v := range，does not conflict, support multidimensional arrays

	dummy := &ast.StructMember{}
	dummy.Type = mb.Type.TypeK
	dummy.Key = "k" + vc
	gen.genWriteVar(dummy, "", hasRet)

	dummy = &ast.StructMember{}
	dummy.Type = mb.Type.TypeV
	dummy.Key = "v" + vc
	dummy.Tag = 1
	gen.genWriteVar(dummy, "", hasRet)

	c.WriteString("}\n")
}

func (gen *GenGo) genWriteVar(v *ast.StructMember, prefix string, hasRet bool) {
	c := &gen.code

	switch v.Type.Type {
	case token.TVector:
		gen.genWriteVector(v, prefix, hasRet)
	case token.TArray:
		gen.genWriteArray(v, prefix, hasRet)
	case token.TMap:
		gen.genWriteMap(v, prefix, hasRet)
	case token.Name:
		if v.Type.CType == token.Enum {
			// tkEnum enumeration processing
			tag := strconv.Itoa(int(v.Tag))
			c.WriteString(`
err = buf.WriteInt32(int32(` + gen.genVariableName(prefix, v.Key) + `),` + tag + `)
` + errString(hasRet) + `
`)
		} else {
			gen.genWriteStruct(v, prefix, hasRet)
		}
	default:
		tag := strconv.Itoa(int(v.Tag))
		c.WriteString(`
err = buf.Write` + utils.UpperFirstLetter(gen.genType(v.Type)) + `(` + gen.genVariableName(prefix, v.Key) + `, ` + tag + `)
` + errString(hasRet) + `
`)
	}
}

func (gen *GenGo) genFunWriteBlock(st *ast.StructInfo) {
	c := &gen.code

	// WriteBlock function head
	c.WriteString(`// WriteBlock encode struct
func (st *` + st.Name + `) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}
`)
}

func (gen *GenGo) genFunWriteTo(st *ast.StructInfo) {
	c := &gen.code

	c.WriteString(`// WriteTo encode struct to buffer
func (st *` + st.Name + `) WriteTo(buf *codec.Buffer) (err error) {
`)
	for _, v := range st.Mb {
		gen.genWriteVar(&v, "st.", false)
	}

	c.WriteString(`
	return err
}
`)
}

func (gen *GenGo) genReadSimpleList(mb *ast.StructMember, prefix string, hasRet bool) {
	c := &gen.code
	unsign := "Int8"
	if mb.Type.TypeK.Unsigned {
		unsign = "Uint8"
	}
	errStr := errString(hasRet)

	c.WriteString(`
_, err = readBuf.SkipTo(codec.BYTE, 0, true)
` + errStr + `
err = readBuf.ReadInt32(&length, 0, true)
` + errStr + `
err = readBuf.ReadSlice` + unsign + `(&` + prefix + mb.Key + `, length, true)
` + errStr + `
`)
}

func (gen *GenGo) genReadVector(mb *ast.StructMember, prefix string, hasRet bool) {
	c := &gen.code
	errStr := errString(hasRet)

	// LIST
	tag := strconv.Itoa(int(mb.Tag))
	vc := strconv.Itoa(gen.vc)
	gen.vc++
	if mb.Require {
		c.WriteString(`
_, ty, err = readBuf.SkipToNoCheck(` + tag + `, true)
` + errStr + `
`)
	} else {
		c.WriteString(`
have, ty, err = readBuf.SkipToNoCheck(` + tag + `, false)
` + errStr + `
if have {`)
		// 结束标记
		defer func() {
			c.WriteString("}\n")
		}()
	}

	c.WriteString(`
if ty == codec.LIST {
	err = readBuf.ReadInt32(&length, 0, true)
  ` + errStr + `
  ` + gen.genVariableName(prefix, mb.Key) + ` = make(` + gen.genType(mb.Type) + `, length)
  ` + genForHead(vc) + `{
`)

	dummy := &ast.StructMember{}
	dummy.Type = mb.Type.TypeK
	dummy.Key = mb.Key + "[i" + vc + "]"
	gen.genReadVar(dummy, prefix, hasRet)

	c.WriteString(`}
} else if ty == codec.SimpleList {
`)
	if mb.Type.TypeK.Type == token.TByte {
		gen.genReadSimpleList(mb, prefix, hasRet)
	} else {
		c.WriteString(`err = fmt.Errorf("not support SimpleList type")
    ` + errStr)
	}
	c.WriteString(`
} else {
  err = fmt.Errorf("require vector, but not")
  ` + errStr + `
}
`)
}

func (gen *GenGo) genReadArray(mb *ast.StructMember, prefix string, hasRet bool) {
	c := &gen.code
	errStr := errString(hasRet)

	// LIST
	tag := strconv.Itoa(int(mb.Tag))
	vc := strconv.Itoa(gen.vc)
	gen.vc++

	if mb.Require {
		c.WriteString(`
_, ty, err = readBuf.SkipToNoCheck(` + tag + `, true)
` + errStr + `
`)
	} else {
		c.WriteString(`
have, ty, err = readBuf.SkipToNoCheck(` + tag + `, false)
` + errStr + `
if have {`)
		// 结束标记
		defer func() {
			c.WriteString("}\n")
		}()
	}

	c.WriteString(`
if ty == codec.LIST {
	err = readBuf.ReadInt32(&length, 0, true)
  ` + errStr + `
  ` + genForHead(vc) + `{
`)

	dummy := &ast.StructMember{}
	dummy.Type = mb.Type.TypeK
	dummy.Key = mb.Key + "[i" + vc + "]"
	gen.genReadVar(dummy, prefix, hasRet)

	c.WriteString(`}
} else if ty == codec.SimpleList {
`)
	if mb.Type.TypeK.Type == token.TByte {
		gen.genReadSimpleList(mb, prefix, hasRet)
	} else {
		c.WriteString(`err = fmt.Errorf("not support SimpleList type")
    ` + errStr)
	}
	c.WriteString(`
} else {
  err = fmt.Errorf("require array, but not")
  ` + errStr + `
}
`)
}

func (gen *GenGo) genReadStruct(mb *ast.StructMember, prefix string, hasRet bool) {
	c := &gen.code
	tag := strconv.Itoa(int(mb.Tag))
	require := "false"
	if mb.Require {
		require = "true"
	}
	c.WriteString(`
err = ` + prefix + mb.Key + `.ReadBlock(readBuf, ` + tag + `, ` + require + `)
` + errString(hasRet) + `
`)
}

func (gen *GenGo) genReadMap(mb *ast.StructMember, prefix string, hasRet bool) {
	c := &gen.code
	tag := strconv.Itoa(int(mb.Tag))
	errStr := errString(hasRet)
	vc := strconv.Itoa(gen.vc)
	gen.vc++

	if mb.Require {
		c.WriteString(`
_, err = readBuf.SkipTo(codec.MAP, ` + tag + `, true)
` + errStr + `
`)
	} else {
		c.WriteString(`
have, err = readBuf.SkipTo(codec.MAP, ` + tag + `, false)
` + errStr + `
if have {`)
		// 结束标记
		defer func() {
			c.WriteString("}\n")
		}()
	}

	c.WriteString(`
err = readBuf.ReadInt32(&length, 0, true)
` + errStr + `
` + gen.genVariableName(prefix, mb.Key) + ` = make(` + gen.genType(mb.Type) + `)
` + genForHead(vc) + `{
	var k` + vc + ` ` + gen.genType(mb.Type.TypeK) + `
	var v` + vc + ` ` + gen.genType(mb.Type.TypeV) + `
`)

	dummy := &ast.StructMember{}
	dummy.Type = mb.Type.TypeK
	dummy.Key = "k" + vc
	gen.genReadVar(dummy, "", hasRet)

	dummy = &ast.StructMember{}
	dummy.Type = mb.Type.TypeV
	dummy.Key = "v" + vc
	dummy.Tag = 1
	gen.genReadVar(dummy, "", hasRet)

	c.WriteString(`
	` + prefix + mb.Key + `[k` + vc + `] = v` + vc + `
}
`)
}

func (gen *GenGo) genReadVar(v *ast.StructMember, prefix string, hasRet bool) {
	c := &gen.code

	switch v.Type.Type {
	case token.TVector:
		gen.genReadVector(v, prefix, hasRet)
	case token.TArray:
		gen.genReadArray(v, prefix, hasRet)
	case token.TMap:
		gen.genReadMap(v, prefix, hasRet)
	case token.Name:
		if v.Type.CType == token.Enum {
			require := "false"
			if v.Require {
				require = "true"
			}
			tag := strconv.Itoa(int(v.Tag))
			c.WriteString(`
err = readBuf.ReadInt32((*int32)(&` + prefix + v.Key + `),` + tag + `, ` + require + `)
` + errString(hasRet) + `
`)
		} else {
			gen.genReadStruct(v, prefix, hasRet)
		}
	default:
		require := "false"
		if v.Require {
			require = "true"
		}
		tag := strconv.Itoa(int(v.Tag))
		c.WriteString(`
err = readBuf.Read` + utils.UpperFirstLetter(gen.genType(v.Type)) + `(&` + prefix + v.Key + `, ` + tag + `, ` + require + `)
` + errString(hasRet) + `
`)
	}
}

func (gen *GenGo) genFunReadFrom(st *ast.StructInfo) {
	c := &gen.code

	c.WriteString(`// ReadFrom reads  from readBuf and put into struct.
func (st *` + st.Name + `) ReadFrom(readBuf *codec.Reader) error {
	var (
		err error
		length int32
		have bool
		ty byte
	)
	st.ResetDefault()

`)

	for _, v := range st.Mb {
		gen.genReadVar(&v, "st.", false)
	}

	c.WriteString(`
	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}
`)
}

func (gen *GenGo) genFunReadBlock(st *ast.StructInfo) {
	c := &gen.code

	c.WriteString(`// ReadBlock reads struct from the given tag , require or optional.
func (st *` + st.Name + `) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ` + st.Name + `, but not exist. tag %d", tag)
		}
		return nil
	}

  	err = st.ReadFrom(readBuf)
  	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}
`)
}

func (gen *GenGo) genStruct(st *ast.StructInfo) {
	gen.vc = 0
	st.Rename()

	gen.genStructDefine(st)
	gen.genFunResetDefault(st)

	gen.genFunReadFrom(st)
	gen.genFunReadBlock(st)

	gen.genFunWriteTo(st)
	gen.genFunWriteBlock(st)
}

func (gen *GenGo) makeEnumName(en *ast.EnumInfo, mb *ast.EnumMember) string {
	return utils.UpperFirstLetter(en.Name) + "_" + utils.UpperFirstLetter(mb.Key)
}

func (gen *GenGo) genEnum(en *ast.EnumInfo) {
	if len(en.Mb) == 0 {
		return
	}

	en.Rename()

	c := &gen.code
	c.WriteString("type " + en.Name + " int32\n")
	c.WriteString("const (\n")
	var it int32
	for _, v := range en.Mb {
		if v.Type == 0 {
			//use value
			c.WriteString(gen.makeEnumName(en, &v) + ` = ` + strconv.Itoa(int(v.Value)) + "\n")
			it = v.Value + 1
		} else if v.Type == 1 {
			// use name
			find := false
			for _, ref := range en.Mb {
				if ref.Key == v.Name {
					find = true
					c.WriteString(gen.makeEnumName(en, &v) + ` = ` + gen.makeEnumName(en, &ref) + "\n")
					it = ref.Value + 1
					break
				}
				if ref.Key == v.Key {
					break
				}
			}
			if !find {
				gen.genErr(v.Name + " not define before use.")
			}
		} else {
			// use auto add
			c.WriteString(gen.makeEnumName(en, &v) + ` = ` + strconv.Itoa(int(it)) + "\n")
			it++
		}

	}

	c.WriteString(")\n")
}

func (gen *GenGo) genConst(cst []ast.ConstInfo) {
	if len(cst) == 0 {
		return
	}

	c := &gen.code
	c.WriteString("//const as define in tars file\n")
	c.WriteString("const (\n")

	for _, v := range gen.module.Const {
		v.Rename()
		c.WriteString(v.Name + " " + gen.genType(v.Type) + " = " + v.Value + "\n")
	}

	c.WriteString(")\n")
}

func (gen *GenGo) genInclude(modules []*ast.ModuleInfo) {
	for _, module := range modules {
		genModule := NewGenGo(gen.opt, module.Name+module.Source)
		genModule.module = module
		genModule.genAll()
	}
}

func (gen *GenGo) genInterface(itf *ast.InterfaceInfo) {
	gen.code.Reset()
	itf.Rename()

	gen.genHead()
	gen.genIFPackage(itf)

	gen.genIFProxy(itf)

	gen.genIFServer(itf)
	gen.genIFServerWithContext(itf)

	gen.genIFDispatch(itf)

	gen.saveToSourceFile(itf.Name + ".tars.go")
}

func (gen *GenGo) genIFProxy(itf *ast.InterfaceInfo) {
	c := &gen.code
	c.WriteString("// " + itf.Name + " struct\n")
	c.WriteString("type " + itf.Name + ` struct {
	servant m.Servant
}
`)

	c.WriteString(`// SetServant sets servant for the service.
func (obj *` + itf.Name + `) SetServant(servant m.Servant) {
	obj.servant = servant
}
`)
	c.WriteString(`// TarsSetTimeout sets the timeout for the servant which is in ms.
func (obj *` + itf.Name + `) TarsSetTimeout(timeout int) {
	obj.servant.TarsSetTimeout(timeout)
}
`)

	c.WriteString(`// TarsSetProtocol sets the protocol for the servant.
func (obj *` + itf.Name + `) TarsSetProtocol(p m.Protocol) {
	obj.servant.TarsSetProtocol(p)
}
`)

	c.WriteString(`// Endpoints returns all active endpoint.Endpoint
func (obj *` + itf.Name + `) Endpoints() []*endpoint.Endpoint {
	return obj.servant.Endpoints()
}
`)

	if gen.opt.AddServant {
		c.WriteString(`// AddServant adds servant  for the service.
func (obj *` + itf.Name + `) AddServant(imp ` + itf.Name + `Servant, servantObj string) {
  tars.AddServant(obj, imp, servantObj)
}
`)
		c.WriteString(`// AddServantWithContext adds servant  for the service with context.
func (obj *` + itf.Name + `) AddServantWithContext(imp ` + itf.Name + `ServantWithContext, servantObj string) {
  tars.AddServantWithContext(obj, imp, servantObj)
}
`)
	}

	for _, v := range itf.Fun {
		gen.genIFProxyFun(itf.Name, &v, false, false)
		gen.genIFProxyFun(itf.Name, &v, true, false)
		gen.genIFProxyFun(itf.Name, &v, true, true)
	}
}

func (gen *GenGo) genIFProxyFun(interfName string, fun *ast.FunInfo, withContext bool, isOneWay bool) {
	c := &gen.code
	if withContext {
		if isOneWay {
			c.WriteString("// " + fun.Name + "OneWayWithContext is the proxy function for the method defined in the tars file, with the context\n")
			c.WriteString("func (obj *" + interfName + ") " + fun.Name + "OneWayWithContext(tarsCtx context.Context,")
		} else {
			c.WriteString("// " + fun.Name + "WithContext is the proxy function for the method defined in the tars file, with the context\n")
			c.WriteString("func (obj *" + interfName + ") " + fun.Name + "WithContext(tarsCtx context.Context,")
		}
	} else {
		c.WriteString("// " + fun.Name + " is the proxy function for the method defined in the tars file, with the context\n")
		c.WriteString("func (obj *" + interfName + ") " + fun.Name + "(")
	}
	for _, v := range fun.Args {
		gen.genArgs(&v)
	}

	c.WriteString(" opts ...map[string]string)")

	// not WithContext caller WithContext method
	if !withContext {
		if fun.HasRet {
			c.WriteString("(" + gen.genType(fun.RetType) + ", error) {\n")
		} else {
			c.WriteString("error { \n")
		}

		c.WriteString("return obj." + fun.Name + "WithContext(context.Background(),")
		for _, v := range fun.Args {
			c.WriteString(v.Name + ",")
		}
		c.WriteString(" opts ...)\n")
		c.WriteString("}\n")
		return
	}

	if fun.HasRet {
		c.WriteString("(ret " + gen.genType(fun.RetType) + ", err error) {\n")
	} else {
		c.WriteString("(err error) {\n")
	}

	c.WriteString(`	var (
		length int32
		have bool
		ty byte
	)
  `)
	c.WriteString("buf := codec.NewBuffer()")
	var isOut bool
	for k, v := range fun.Args {
		if v.IsOut {
			isOut = true
		}
		dummy := &ast.StructMember{}
		dummy.Type = v.Type
		dummy.Key = v.Name
		dummy.Tag = int32(k + 1)
		if v.IsOut {
			dummy.Key = "(*" + dummy.Key + ")"
		}
		gen.genWriteVar(dummy, "", fun.HasRet)
	}
	// empty args and below separate
	c.WriteString("\n")
	errStr := errString(fun.HasRet)

	// trace
	if !isOneWay && !gen.opt.WithoutTrace {
		c.WriteString(`
trace, ok := current.GetTarsTrace(tarsCtx)
if ok && trace.Call() {
	var traceParam string
	trace.NewSpan()
	traceParamFlag := trace.NeedTraceParam(tarstrace.EstCS, uint(buf.Len()))
	if traceParamFlag == tarstrace.EnpNormal {
		value := map[string]interface{}{}
`)
		for _, v := range fun.Args {
			if !v.IsOut {
				c.WriteString(`value["` + v.Name + `"] = ` + v.Name + "\n")
			}
		}
		c.WriteString(`jm, _ := json.Marshal(value)
		traceParam = string(jm)
	} else if traceParamFlag == tarstrace.EnpOverMaxLen {
`)
		c.WriteString("traceParam = `{\"trace_param_over_max_len\":true}`")
		c.WriteString(`
	}
	tars.Trace(trace.GetTraceKey(tarstrace.EstCS), tarstrace.AnnotationCS, tars.GetClientConfig().ModuleName, obj.servant.Name(), "` + fun.Name + `", 0, traceParam, "")
}`)
		c.WriteString("\n\n")
	}
	c.WriteString(`var statusMap map[string]string
var contextMap map[string]string
if len(opts) == 1{
	contextMap =opts[0]
}else if len(opts) == 2 {
	contextMap = opts[0]
	statusMap = opts[1]
}

tarsResp := new(requestf.ResponsePacket)`)

	if isOneWay {
		c.WriteString(`
		err = obj.servant.TarsInvoke(tarsCtx, 1, "` + fun.OriginName + `", buf.ToBytes(), statusMap, contextMap, tarsResp)
		` + errStr + `
		`)
	} else {
		c.WriteString(`
		err = obj.servant.TarsInvoke(tarsCtx, 0, "` + fun.OriginName + `", buf.ToBytes(), statusMap, contextMap, tarsResp)
		` + errStr + `
		`)
	}

	if (isOut || fun.HasRet) && !isOneWay {
		c.WriteString("readBuf := codec.NewReader(tools.Int8ToByte(tarsResp.SBuffer))")
	}
	if fun.HasRet && !isOneWay {
		dummy := &ast.StructMember{}
		dummy.Type = fun.RetType
		dummy.Key = "ret"
		dummy.Tag = 0
		dummy.Require = true
		gen.genReadVar(dummy, "", fun.HasRet)
	}

	if !isOneWay {
		for k, v := range fun.Args {
			if v.IsOut {
				dummy := &ast.StructMember{}
				dummy.Type = v.Type
				dummy.Key = "(*" + v.Name + ")"
				dummy.Tag = int32(k + 1)
				dummy.Require = true
				gen.genReadVar(dummy, "", fun.HasRet)
			}
		}
		if withContext && !gen.opt.WithoutTrace {
			traceParamFlag := "traceParamFlag := trace.NeedTraceParam(tarstrace.EstCR, uint(0))"
			if isOut || fun.HasRet {
				traceParamFlag = "traceParamFlag := trace.NeedTraceParam(tarstrace.EstCR, uint(readBuf.Len()))"
			}
			c.WriteString(`
if ok && trace.Call() {
	var traceParam string
	` + traceParamFlag + `
	if traceParamFlag == tarstrace.EnpNormal {
		value := map[string]interface{}{}
`)
			if fun.HasRet {
				c.WriteString(`value[""] = ret` + "\n")
			}
			for _, v := range fun.Args {
				if v.IsOut {
					c.WriteString(`value["` + v.Name + `"] = *` + v.Name + "\n")
				}
			}
			c.WriteString(`jm, _ := json.Marshal(value)
		traceParam = string(jm)
	} else if traceParamFlag == tarstrace.EnpOverMaxLen {
`)
			c.WriteString("traceParam = `{\"trace_param_over_max_len\":true}`")
			c.WriteString(`
	}
	tars.Trace(trace.GetTraceKey(tarstrace.EstCR), tarstrace.AnnotationCR, tars.GetClientConfig().ModuleName, obj.servant.Name(), "` + fun.Name + `", tarsResp.IRet, traceParam, "")
}`)
			c.WriteString("\n\n")
		}

		c.WriteString(`
	if len(opts) == 1 {
		for k := range(contextMap){
			delete(contextMap, k)
		}
		for k, v := range(tarsResp.Context){
			contextMap[k] = v
		}
	} else if len(opts) == 2 {
		for k := range(contextMap){
			delete(contextMap, k)
		}
		for k, v := range(tarsResp.Context){
			contextMap[k] = v
		}
		for k := range(statusMap){
			delete(statusMap, k)
		}
		for k, v := range(tarsResp.Status){
			statusMap[k] = v
		}
	}`)
	}

	c.WriteString(`
  _ = length
  _ = have
  _ = ty
`)
	if fun.HasRet {
		c.WriteString("return ret, nil\n")
	} else {
		c.WriteString("return nil\n")
	}

	c.WriteString("}\n")
}

func (gen *GenGo) genArgs(arg *ast.ArgInfo) {
	c := &gen.code
	c.WriteString(arg.Name + " ")
	if arg.IsOut || arg.Type.CType == token.Struct {
		c.WriteString("*")
	}

	c.WriteString(gen.genType(arg.Type) + ",")
}

func (gen *GenGo) genIFServer(itf *ast.InterfaceInfo) {
	c := &gen.code
	c.WriteString("type " + itf.Name + "Servant interface {\n")
	for _, v := range itf.Fun {
		gen.genIFServerFun(&v)
	}
	c.WriteString("}\n")
}

func (gen *GenGo) genIFServerWithContext(itf *ast.InterfaceInfo) {
	c := &gen.code
	c.WriteString("type " + itf.Name + "ServantWithContext interface {\n")
	for _, v := range itf.Fun {
		gen.genIFServerFunWithContext(&v)
	}
	c.WriteString("} \n")
}

func (gen *GenGo) genIFServerFun(fun *ast.FunInfo) {
	c := &gen.code
	c.WriteString(fun.Name + "(")
	for _, v := range fun.Args {
		gen.genArgs(&v)
	}
	c.WriteString(")(")

	if fun.HasRet {
		c.WriteString("ret " + gen.genType(fun.RetType) + ", ")
	}
	c.WriteString("err error)\n")
}

func (gen *GenGo) genIFServerFunWithContext(fun *ast.FunInfo) {
	c := &gen.code
	c.WriteString(fun.Name + "(tarsCtx context.Context, ")
	for _, v := range fun.Args {
		gen.genArgs(&v)
	}
	c.WriteString(")(")

	if fun.HasRet {
		c.WriteString("ret " + gen.genType(fun.RetType) + ", ")
	}
	c.WriteString("err error)\n")
}

func (gen *GenGo) genIFDispatch(itf *ast.InterfaceInfo) {
	c := &gen.code
	c.WriteString("// Dispatch is used to call the server side implement for the method defined in the tars file. withContext shows using context or not.  \n")
	c.WriteString("func(obj *" + itf.Name + `) Dispatch(tarsCtx context.Context, val interface{}, tarsReq *requestf.RequestPacket, tarsResp *requestf.ResponsePacket, withContext bool) (err error) {
	var (
		length int32
		have bool
		ty byte
	)
  `)

	var param bool
	for _, v := range itf.Fun {
		if len(v.Args) > 0 {
			param = true
			break
		}
	}

	if param {
		c.WriteString("readBuf := codec.NewReader(tools.Int8ToByte(tarsReq.SBuffer))")
	} else {
		c.WriteString("readBuf := codec.NewReader(nil)")
	}
	c.WriteString(`
	buf := codec.NewBuffer()
	switch tarsReq.SFuncName {
`)

	for _, v := range itf.Fun {
		gen.genSwitchCase(itf.Name, &v)
	}

	c.WriteString(`
	default:
		return fmt.Errorf("func mismatch")
	}
	var statusMap map[string]string
	if status, ok := current.GetResponseStatus(tarsCtx); ok  && status != nil {
		statusMap = status
	}
	var contextMap map[string]string
	if ctx, ok := current.GetResponseContext(tarsCtx); ok && ctx != nil  {
		contextMap = ctx
	}
	*tarsResp = requestf.ResponsePacket{
		IVersion:     tarsReq.IVersion,
		CPacketType:  0,
		IRequestId:   tarsReq.IRequestId,
		IMessageType: 0,
		IRet:         0,
		SBuffer:      tools.ByteToInt8(buf.ToBytes()),
		Status:       statusMap,
		SResultDesc:  "",
		Context:      contextMap,
	}

	_ = readBuf
	_ = buf
	_ = length
	_ = have
	_ = ty
	return nil
}
`)
}

func (gen *GenGo) genSwitchCase(tname string, fun *ast.FunInfo) {
	c := &gen.code
	c.WriteString(`case "` + fun.OriginName + `":` + "\n")

	inArgsCount := 0
	outArgsCount := 0
	for _, v := range fun.Args {
		c.WriteString("var " + v.Name + " " + gen.genType(v.Type) + "\n")
		if v.Type.Type == token.TMap {
			c.WriteString(v.Name + " = make(" + gen.genType(v.Type) + ")\n")
		} else if v.Type.Type == token.TVector {
			c.WriteString(v.Name + " = make(" + gen.genType(v.Type) + ", 0)\n")
		}
		if v.IsOut {
			outArgsCount++
		} else {
			inArgsCount++
		}
	}

	//fmt.Println("args count, in, out:", inArgsCount, outArgsCount)

	c.WriteString("\n")

	if inArgsCount > 0 {
		c.WriteString("if tarsReq.IVersion == basef.TARSVERSION {\n")

		for k, v := range fun.Args {

			if !v.IsOut {
				dummy := &ast.StructMember{}
				dummy.Type = v.Type
				dummy.Key = v.Name
				dummy.Tag = int32(k + 1)
				dummy.Require = true
				gen.genReadVar(dummy, "", false)
			}
		}

		c.WriteString(`} else if tarsReq.IVersion == basef.TUPVERSION {
		reqTup := tup.NewUniAttribute()
		reqTup.Decode(readBuf)

		var tupBuffer []byte

		`)
		for _, v := range fun.Args {
			if !v.IsOut {
				c.WriteString("\n")
				c.WriteString(`reqTup.GetBuffer("` + v.Name + `", &tupBuffer)` + "\n")
				c.WriteString("readBuf.Reset(tupBuffer)")

				dummy := &ast.StructMember{}
				dummy.Type = v.Type
				dummy.Key = v.Name
				dummy.Tag = 0
				dummy.Require = true
				gen.genReadVar(dummy, "", false)
			}
		}

		c.WriteString(`} else if tarsReq.IVersion == basef.JSONVERSION {
		var jsonData map[string]interface{}
		decoder := json.NewDecoder(bytes.NewReader(readBuf.ToBytes()))
		decoder.UseNumber()
		err = decoder.Decode(&jsonData)
		if err != nil {
			return fmt.Errorf("decode reqpacket failed, error: %+v", err)
		}
		`)

		for _, v := range fun.Args {
			if !v.IsOut {
				c.WriteString("{\n")
				c.WriteString(`jsonStr, _ := json.Marshal(jsonData["` + v.Name + `"])` + "\n")
				if v.Type.CType == token.Struct {
					c.WriteString(v.Name + ".ResetDefault()\n")
				}
				c.WriteString("if err = json.Unmarshal(jsonStr, &" + v.Name + "); err != nil {")
				c.WriteString(`
					return err
				}
				}
				`)
			}
		}

		c.WriteString(`
		} else {
			err = fmt.Errorf("decode reqpacket fail, error version: %d", tarsReq.IVersion)
			return err
		}`)

		c.WriteString("\n\n")
	}
	if !gen.opt.WithoutTrace {
		c.WriteString(`
trace, ok := current.GetTarsTrace(tarsCtx)
if ok && trace.Call() {
	var traceParam string
	traceParamFlag := trace.NeedTraceParam(tarstrace.EstSR, uint(readBuf.Len()))
	if traceParamFlag == tarstrace.EnpNormal {
		value := map[string]interface{}{}
`)
		for _, v := range fun.Args {
			if !v.IsOut {
				c.WriteString(`value["` + v.Name + `"] = ` + v.Name + "\n")
			}
		}
		c.WriteString(`jm, _ := json.Marshal(value)
		traceParam = string(jm)
	} else if traceParamFlag == tarstrace.EnpOverMaxLen {
`)
		c.WriteString("traceParam = `{\"trace_param_over_max_len\":true}`")
		c.WriteString(`
	}
	tars.Trace(trace.GetTraceKey(tarstrace.EstSR), tarstrace.AnnotationSR, tars.GetClientConfig().ModuleName, tarsReq.SServantName, "` + fun.OriginName + `", 0, traceParam, "")
}`)
		c.WriteString("\n\n")
	}

	if fun.HasRet {
		c.WriteString("var funRet " + gen.genType(fun.RetType) + "\n")

		c.WriteString(`if !withContext {
		imp := val.(` + tname + `Servant)
		funRet, err = imp.` + fun.Name + `(`)
		for _, v := range fun.Args {
			if v.IsOut || v.Type.CType == token.Struct {
				c.WriteString("&" + v.Name + ",")
			} else {
				c.WriteString(v.Name + ",")
			}
		}
		c.WriteString(")")

		c.WriteString(`
		} else {
		imp := val.(` + tname + `ServantWithContext)
		funRet, err = imp.` + fun.Name + `(tarsCtx ,`)
		for _, v := range fun.Args {
			if v.IsOut || v.Type.CType == token.Struct {
				c.WriteString("&" + v.Name + ",")
			} else {
				c.WriteString(v.Name + ",")
			}
		}
		c.WriteString(") \n}\n")

	} else {
		c.WriteString(`if !withContext {
		imp := val.(` + tname + `Servant)
		err = imp.` + fun.Name + `(`)
		for _, v := range fun.Args {
			if v.IsOut || v.Type.CType == token.Struct {
				c.WriteString("&" + v.Name + ",")
			} else {
				c.WriteString(v.Name + ",")
			}
		}
		c.WriteString(")")

		c.WriteString(`
		} else {
		imp := val.(` + tname + `ServantWithContext)
		err = imp.` + fun.Name + `(tarsCtx ,`)
		for _, v := range fun.Args {
			if v.IsOut || v.Type.CType == token.Struct {
				c.WriteString("&" + v.Name + ",")
			} else {
				c.WriteString(v.Name + ",")
			}
		}
		c.WriteString(") \n}\n")
	}

	if gen.opt.DispatchReporter {
		var inArgStr, outArgStr, retArgStr string
		if fun.HasRet {
			retArgStr = "funRet, err"
		} else {
			retArgStr = "err"
		}
		for _, v := range fun.Args {
			prefix := ""
			if v.Type.CType == token.Struct {
				prefix = "&"
			}
			if v.IsOut {
				outArgStr += prefix + v.Name + ","
			} else {
				inArgStr += prefix + v.Name + ","
			}
		}
		c.WriteString(`if dp := tars.GetDispatchReporter(); dp != nil {
			dp(tarsCtx, []interface{}{` + inArgStr + `}, []interface{}{` + outArgStr + `}, []interface{}{` + retArgStr + `})
		}`)

	}
	c.WriteString(`
	if err != nil {
		return err
	}
	`)

	c.WriteString(`
	if tarsReq.IVersion == basef.TARSVERSION {
	buf.Reset()
	`)

	if fun.HasRet {
		dummy := &ast.StructMember{}
		dummy.Type = fun.RetType
		dummy.Key = "funRet"
		dummy.Tag = 0
		dummy.Require = true
		gen.genWriteVar(dummy, "", false)
	}

	for k, v := range fun.Args {
		if v.IsOut {
			dummy := &ast.StructMember{}
			dummy.Type = v.Type
			dummy.Key = v.Name
			dummy.Tag = int32(k + 1)
			dummy.Require = true
			gen.genWriteVar(dummy, "", false)
		}
	}

	c.WriteString(`
} else if tarsReq.IVersion == basef.TUPVERSION {
rspTup := tup.NewUniAttribute()
`)
	if fun.HasRet {
		dummy := &ast.StructMember{}
		dummy.Type = fun.RetType
		dummy.Key = "funRet"
		dummy.Tag = 0
		dummy.Require = true
		gen.genWriteVar(dummy, "", false)

		c.WriteString(`
		rspTup.PutBuffer("", buf.ToBytes())
		rspTup.PutBuffer("tars_ret", buf.ToBytes())
`)
	}

	for _, v := range fun.Args {
		if v.IsOut {
			c.WriteString(`
		buf.Reset()`)
			dummy := &ast.StructMember{}
			dummy.Type = v.Type
			dummy.Key = v.Name
			dummy.Tag = 0
			dummy.Require = true
			gen.genWriteVar(dummy, "", false)

			c.WriteString(`rspTup.PutBuffer("` + v.Name + `", buf.ToBytes())` + "\n")
		}
	}

	c.WriteString(`
	buf.Reset()
	err = rspTup.Encode(buf)
	if err != nil {
		return err
	}
} else if tarsReq.IVersion == basef.JSONVERSION {
	rspJson := map[string]interface{}{}
`)
	if fun.HasRet {
		c.WriteString(`rspJson["tars_ret"] = funRet` + "\n")
	}

	for _, v := range fun.Args {
		if v.IsOut {
			c.WriteString(`rspJson["` + v.Name + `"] = ` + v.Name + "\n")
		}
	}

	c.WriteString(`
		var rspByte []byte
		if rspByte, err = json.Marshal(rspJson); err != nil {
			return err
		}

		buf.Reset()
		err = buf.WriteSliceUint8(rspByte)
		if err != nil {
			return err
		}
}`)

	c.WriteString("\n")
	if !gen.opt.WithoutTrace {
		c.WriteString(`
if ok && trace.Call() {
	var traceParam string
	traceParamFlag := trace.NeedTraceParam(tarstrace.EstSS, uint(buf.Len()))
	if traceParamFlag == tarstrace.EnpNormal {
		value := map[string]interface{}{}
`)
		if fun.HasRet {
			c.WriteString(`value[""] = funRet` + "\n")
		}
		for _, v := range fun.Args {
			if v.IsOut {
				c.WriteString(`value["` + v.Name + `"] = ` + v.Name + "\n")
			}
		}
		c.WriteString(`jm, _ := json.Marshal(value)
		traceParam = string(jm)
	} else if traceParamFlag == tarstrace.EnpOverMaxLen {
`)
		c.WriteString("traceParam = `{\"trace_param_over_max_len\":true}`")
		c.WriteString(`
}
	tars.Trace(trace.GetTraceKey(tarstrace.EstSS), tarstrace.AnnotationSS, tars.GetClientConfig().ModuleName, tarsReq.SServantName, "` + fun.OriginName + `", 0, traceParam, "")
}
`)
	}
}
