// Package authf comment
// This file was generated by tars2go 1.2.2
// Generated from AuthF.tars
package authf

import (
	"fmt"

	"github.com/TarsCloud/TarsGo/tars/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

type AUTH_STATE int32

const (
	AUTH_STATE_AUTH_INIT            = -127
	AUTH_STATE_AUTH_SUCC            = 0
	AUTH_STATE_AUTH_PROTO_ERR       = -100
	AUTH_STATE_AUTH_WRONG_OBJ       = -101
	AUTH_STATE_AUTH_WRONG_AK        = -102
	AUTH_STATE_AUTH_WRONG_TIME      = -103
	AUTH_STATE_AUTH_NOT_SUPPORT_ENC = -104
	AUTH_STATE_AUTH_DEC_FAIL        = -105
	AUTH_STATE_AUTH_ERROR           = -106
)

type AUTH_TYPE int32

const (
	AUTH_TYPE_AUTH_TYPENONE  = 0
	AUTH_TYPE_AUTH_TYPELOCAL = 1
)

// BasicAuthInfo struct implement
type BasicAuthInfo struct {
	SObjName        string `json:"sObjName"`
	SAccessKey      string `json:"sAccessKey"`
	SSecretKey      string `json:"sSecretKey"`
	SHashSecretKey2 string `json:"sHashSecretKey2"`
}

func (st *BasicAuthInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BasicAuthInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.SObjName, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SAccessKey, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SSecretKey, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SHashSecretKey2, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BasicAuthInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BasicAuthInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BasicAuthInfo) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.SObjName, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SAccessKey, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SSecretKey, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SHashSecretKey2, 4)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *BasicAuthInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BasicAuthPackage struct implement
type BasicAuthPackage struct {
	SObjName    string `json:"sObjName"`
	SAccessKey  string `json:"sAccessKey"`
	ITime       int64  `json:"iTime"`
	SHashMethod string `json:"sHashMethod"`
	SSignature  string `json:"sSignature"`
}

func (st *BasicAuthPackage) ResetDefault() {
	st.SHashMethod = "sha1"
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BasicAuthPackage) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.SObjName, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SAccessKey, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.ITime, 3, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SHashMethod, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SSignature, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BasicAuthPackage) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BasicAuthPackage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BasicAuthPackage) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.SObjName, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SAccessKey, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.ITime, 3)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SHashMethod, 4)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SSignature, 5)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *BasicAuthPackage) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TokenKey struct implement
type TokenKey struct {
	SApplication string `json:"sApplication"`
	SServer      string `json:"sServer"`
	SObjName     string `json:"sObjName"`
}

func (st *TokenKey) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TokenKey) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.SApplication, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SServer, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SObjName, 3, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TokenKey) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TokenKey, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TokenKey) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.SApplication, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SServer, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SObjName, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *TokenKey) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AuthRequest struct implement
type AuthRequest struct {
	SKey   TokenKey `json:"sKey"`
	SToken string   `json:"sToken"`
}

func (st *AuthRequest) ResetDefault() {
	st.SKey.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AuthRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.SKey.ReadBlock(readBuf, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SToken, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AuthRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AuthRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AuthRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = st.SKey.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SToken, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AuthRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TokenRequest struct implement
type TokenRequest struct {
	VObjName []string `json:"vObjName"`
}

func (st *TokenRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TokenRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}

	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}

		st.VObjName = make([]string, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {

			err = readBuf.ReadString(&st.VObjName[i0], 0, false)
			if err != nil {
				return err
			}

		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}

	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}

	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TokenRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TokenRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TokenRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.VObjName)), 0)
	if err != nil {
		return err
	}

	for _, v := range st.VObjName {

		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *TokenRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TokenResponse struct implement
type TokenResponse struct {
	SObjName string            `json:"sObjName"`
	MTokens  map[string]string `json:"mTokens"`
}

func (st *TokenResponse) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TokenResponse) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.SObjName, 1, true)
	if err != nil {
		return err
	}

	_, err = readBuf.SkipTo(codec.MAP, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt32(&length, 0, true)
	if err != nil {
		return err
	}

	st.MTokens = make(map[string]string)
	for i0, e0 := int32(0), length; i0 < e0; i0++ {
		var k0 string
		var v0 string

		err = readBuf.ReadString(&k0, 0, false)
		if err != nil {
			return err
		}

		err = readBuf.ReadString(&v0, 1, false)
		if err != nil {
			return err
		}

		st.MTokens[k0] = v0
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TokenResponse) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TokenResponse, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TokenResponse) WriteTo(buf *codec.Buffer) (err error) {

	err = buf.WriteString(st.SObjName, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt32(int32(len(st.MTokens)), 0)
	if err != nil {
		return err
	}

	for k1, v1 := range st.MTokens {

		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}

		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}

	}

	return err
}

// WriteBlock encode struct
func (st *TokenResponse) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ApplyTokenRequest struct implement
type ApplyTokenRequest struct {
	SKey TokenKey `json:"sKey"`
}

func (st *ApplyTokenRequest) ResetDefault() {
	st.SKey.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ApplyTokenRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.SKey.ReadBlock(readBuf, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ApplyTokenRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ApplyTokenRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ApplyTokenRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = st.SKey.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ApplyTokenRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ApplyTokenResponse struct implement
type ApplyTokenResponse struct {
	SKey   TokenKey `json:"sKey"`
	SToken string   `json:"sToken"`
}

func (st *ApplyTokenResponse) ResetDefault() {
	st.SKey.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ApplyTokenResponse) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.SKey.ReadBlock(readBuf, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SToken, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ApplyTokenResponse) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ApplyTokenResponse, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ApplyTokenResponse) WriteTo(buf *codec.Buffer) (err error) {

	err = st.SKey.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SToken, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ApplyTokenResponse) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DeleteTokenRequest struct implement
type DeleteTokenRequest struct {
	SKey TokenKey `json:"sKey"`
}

func (st *DeleteTokenRequest) ResetDefault() {
	st.SKey.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DeleteTokenRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.SKey.ReadBlock(readBuf, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DeleteTokenRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DeleteTokenRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DeleteTokenRequest) WriteTo(buf *codec.Buffer) (err error) {

	err = st.SKey.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DeleteTokenRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}
