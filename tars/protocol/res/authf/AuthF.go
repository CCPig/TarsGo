// Code generated by tars2go 1.2.3, DO NOT EDIT.
// This file was generated from AuthF.tars
// Package authf comment
package authf

import (
	"fmt"

	"github.com/TarsCloud/TarsGo/tars/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

//go:generate stringer -type AUTH_STATE -trimprefix AUTH_STATE_ -output auth_state_string.go
type AUTH_STATE int32

const (
	AUTH_STATE_AUTH_INIT            AUTH_STATE = -127
	AUTH_STATE_AUTH_SUCC            AUTH_STATE = 0
	AUTH_STATE_AUTH_PROTO_ERR       AUTH_STATE = -100
	AUTH_STATE_AUTH_WRONG_OBJ       AUTH_STATE = -101
	AUTH_STATE_AUTH_WRONG_AK        AUTH_STATE = -102
	AUTH_STATE_AUTH_WRONG_TIME      AUTH_STATE = -103
	AUTH_STATE_AUTH_NOT_SUPPORT_ENC AUTH_STATE = -104
	AUTH_STATE_AUTH_DEC_FAIL        AUTH_STATE = -105
	AUTH_STATE_AUTH_ERROR           AUTH_STATE = -106
)

//go:generate stringer -type AUTH_TYPE -trimprefix AUTH_TYPE_ -output auth_type_string.go
type AUTH_TYPE int32

const (
	AUTH_TYPE_AUTH_TYPENONE  AUTH_TYPE = 0
	AUTH_TYPE_AUTH_TYPELOCAL AUTH_TYPE = 1
)

// BasicAuthInfo struct implement
type BasicAuthInfo struct {
	SObjName        string `json:"sObjName" tars:"sObjName,tag:1,require:false"`
	SAccessKey      string `json:"sAccessKey" tars:"sAccessKey,tag:2,require:false"`
	SSecretKey      string `json:"sSecretKey" tars:"sSecretKey,tag:3,require:false"`
	SHashSecretKey2 string `json:"sHashSecretKey2" tars:"sHashSecretKey2,tag:4,require:false"`
}

func (st *BasicAuthInfo) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BasicAuthInfo) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.SObjName, 1, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SAccessKey, 2, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SSecretKey, 3, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SHashSecretKey2, 4, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BasicAuthInfo) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BasicAuthInfo, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BasicAuthInfo) WriteTo(buf *codec.Buffer) (err error) {
	if st.SObjName != "" {
		err = buf.WriteString(st.SObjName, 1)
		if err != nil {
			return err
		}
	}

	if st.SAccessKey != "" {
		err = buf.WriteString(st.SAccessKey, 2)
		if err != nil {
			return err
		}
	}

	if st.SSecretKey != "" {
		err = buf.WriteString(st.SSecretKey, 3)
		if err != nil {
			return err
		}
	}

	if st.SHashSecretKey2 != "" {
		err = buf.WriteString(st.SHashSecretKey2, 4)
		if err != nil {
			return err
		}
	}

	return err
}

// WriteBlock encode struct
func (st *BasicAuthInfo) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// BasicAuthPackage struct implement
type BasicAuthPackage struct {
	SObjName    string `json:"sObjName" tars:"sObjName,tag:1,require:true"`
	SAccessKey  string `json:"sAccessKey" tars:"sAccessKey,tag:2,require:true"`
	ITime       int64  `json:"iTime" tars:"iTime,tag:3,require:true"`
	SHashMethod string `json:"sHashMethod" tars:"sHashMethod,tag:4,require:false"`
	SSignature  string `json:"sSignature" tars:"sSignature,tag:5,require:false"`
}

func (st *BasicAuthPackage) ResetDefault() {
	st.SHashMethod = "sha1"
}

// ReadFrom reads  from readBuf and put into struct.
func (st *BasicAuthPackage) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.SObjName, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SAccessKey, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadInt64(&st.ITime, 3, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SHashMethod, 4, false)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SSignature, 5, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *BasicAuthPackage) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require BasicAuthPackage, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *BasicAuthPackage) WriteTo(buf *codec.Buffer) (err error) {
	err = buf.WriteString(st.SObjName, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SAccessKey, 2)
	if err != nil {
		return err
	}

	err = buf.WriteInt64(st.ITime, 3)
	if err != nil {
		return err
	}

	if st.SHashMethod != "sha1" {
		err = buf.WriteString(st.SHashMethod, 4)
		if err != nil {
			return err
		}
	}

	if st.SSignature != "" {
		err = buf.WriteString(st.SSignature, 5)
		if err != nil {
			return err
		}
	}

	return err
}

// WriteBlock encode struct
func (st *BasicAuthPackage) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TokenKey struct implement
type TokenKey struct {
	SApplication string `json:"sApplication" tars:"sApplication,tag:1,require:true"`
	SServer      string `json:"sServer" tars:"sServer,tag:2,require:true"`
	SObjName     string `json:"sObjName" tars:"sObjName,tag:3,require:true"`
}

func (st *TokenKey) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TokenKey) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.SApplication, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SServer, 2, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SObjName, 3, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TokenKey) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TokenKey, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TokenKey) WriteTo(buf *codec.Buffer) (err error) {
	err = buf.WriteString(st.SApplication, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SServer, 2)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SObjName, 3)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *TokenKey) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// AuthRequest struct implement
type AuthRequest struct {
	SKey   TokenKey `json:"sKey" tars:"sKey,tag:1,require:true"`
	SToken string   `json:"sToken" tars:"sToken,tag:2,require:true"`
}

func (st *AuthRequest) ResetDefault() {
	st.SKey.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *AuthRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.SKey.ReadBlock(readBuf, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SToken, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *AuthRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require AuthRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *AuthRequest) WriteTo(buf *codec.Buffer) (err error) {
	err = st.SKey.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SToken, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *AuthRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TokenRequest struct implement
type TokenRequest struct {
	VObjName []string `json:"vObjName" tars:"vObjName,tag:1,require:true"`
}

func (st *TokenRequest) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TokenRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	_, ty, err = readBuf.SkipToNoCheck(1, true)
	if err != nil {
		return err
	}
	if ty == codec.LIST {
		err = readBuf.ReadInt32(&length, 0, true)
		if err != nil {
			return err
		}
		st.VObjName = make([]string, length)
		for i0, e0 := int32(0), length; i0 < e0; i0++ {
			err = readBuf.ReadString(&st.VObjName[i0], 0, true)
			if err != nil {
				return err
			}
		}
	} else if ty == codec.SimpleList {
		err = fmt.Errorf("not support SimpleList type")
		if err != nil {
			return err
		}
	} else {
		err = fmt.Errorf("require vector, but not")
		if err != nil {
			return err
		}
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TokenRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TokenRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TokenRequest) WriteTo(buf *codec.Buffer) (err error) {
	err = buf.WriteHead(codec.LIST, 1)
	if err != nil {
		return err
	}
	err = buf.WriteInt32(int32(len(st.VObjName)), 0)
	if err != nil {
		return err
	}
	for _, v := range st.VObjName {
		err = buf.WriteString(v, 0)
		if err != nil {
			return err
		}
	}

	return err
}

// WriteBlock encode struct
func (st *TokenRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// TokenResponse struct implement
type TokenResponse struct {
	SObjName string            `json:"sObjName" tars:"sObjName,tag:1,require:true"`
	MTokens  map[string]string `json:"mTokens" tars:"mTokens,tag:2,require:true"`
}

func (st *TokenResponse) ResetDefault() {
}

// ReadFrom reads  from readBuf and put into struct.
func (st *TokenResponse) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = readBuf.ReadString(&st.SObjName, 1, true)
	if err != nil {
		return err
	}

	_, err = readBuf.SkipTo(codec.MAP, 2, true)
	if err != nil {
		return err
	}
	err = readBuf.ReadInt32(&length, 0, true)
	if err != nil {
		return err
	}
	st.MTokens = make(map[string]string)
	for i0, e0 := int32(0), length; i0 < e0; i0++ {
		var k0 string
		var v0 string
		err = readBuf.ReadString(&k0, 0, true)
		if err != nil {
			return err
		}
		err = readBuf.ReadString(&v0, 1, true)
		if err != nil {
			return err
		}
		st.MTokens[k0] = v0
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *TokenResponse) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require TokenResponse, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *TokenResponse) WriteTo(buf *codec.Buffer) (err error) {
	err = buf.WriteString(st.SObjName, 1)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.MAP, 2)
	if err != nil {
		return err
	}
	err = buf.WriteInt32(int32(len(st.MTokens)), 0)
	if err != nil {
		return err
	}
	for k1, v1 := range st.MTokens {
		err = buf.WriteString(k1, 0)
		if err != nil {
			return err
		}
		err = buf.WriteString(v1, 1)
		if err != nil {
			return err
		}
	}

	return err
}

// WriteBlock encode struct
func (st *TokenResponse) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ApplyTokenRequest struct implement
type ApplyTokenRequest struct {
	SKey TokenKey `json:"sKey" tars:"sKey,tag:1,require:true"`
}

func (st *ApplyTokenRequest) ResetDefault() {
	st.SKey.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ApplyTokenRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.SKey.ReadBlock(readBuf, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ApplyTokenRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ApplyTokenRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ApplyTokenRequest) WriteTo(buf *codec.Buffer) (err error) {
	err = st.SKey.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ApplyTokenRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// ApplyTokenResponse struct implement
type ApplyTokenResponse struct {
	SKey   TokenKey `json:"sKey" tars:"sKey,tag:1,require:true"`
	SToken string   `json:"sToken" tars:"sToken,tag:2,require:true"`
}

func (st *ApplyTokenResponse) ResetDefault() {
	st.SKey.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *ApplyTokenResponse) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.SKey.ReadBlock(readBuf, 1, true)
	if err != nil {
		return err
	}

	err = readBuf.ReadString(&st.SToken, 2, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *ApplyTokenResponse) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ApplyTokenResponse, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *ApplyTokenResponse) WriteTo(buf *codec.Buffer) (err error) {
	err = st.SKey.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	err = buf.WriteString(st.SToken, 2)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *ApplyTokenResponse) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}

// DeleteTokenRequest struct implement
type DeleteTokenRequest struct {
	SKey TokenKey `json:"sKey" tars:"sKey,tag:1,require:true"`
}

func (st *DeleteTokenRequest) ResetDefault() {
	st.SKey.ResetDefault()
}

// ReadFrom reads  from readBuf and put into struct.
func (st *DeleteTokenRequest) ReadFrom(readBuf *codec.Reader) error {
	var (
		err    error
		length int32
		have   bool
		ty     byte
	)
	st.ResetDefault()

	err = st.SKey.ReadBlock(readBuf, 1, true)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

// ReadBlock reads struct from the given tag , require or optional.
func (st *DeleteTokenRequest) ReadBlock(readBuf *codec.Reader, tag byte, require bool) error {
	var (
		err  error
		have bool
	)
	st.ResetDefault()

	have, err = readBuf.SkipTo(codec.StructBegin, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require DeleteTokenRequest, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(readBuf)
	if err != nil {
		return err
	}

	err = readBuf.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

// WriteTo encode struct to buffer
func (st *DeleteTokenRequest) WriteTo(buf *codec.Buffer) (err error) {
	err = st.SKey.WriteBlock(buf, 1)
	if err != nil {
		return err
	}

	return err
}

// WriteBlock encode struct
func (st *DeleteTokenRequest) WriteBlock(buf *codec.Buffer, tag byte) error {
	var err error
	err = buf.WriteHead(codec.StructBegin, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(buf)
	if err != nil {
		return err
	}

	err = buf.WriteHead(codec.StructEnd, 0)
	if err != nil {
		return err
	}
	return nil
}
